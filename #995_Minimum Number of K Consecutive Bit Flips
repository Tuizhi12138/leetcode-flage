class Solution(object):
    def minKBitFlips(self, A, K):
        """
        :type A: List[int]
        :type K: int
        :rtype: int
        第一次提交使用暴力法挨个反转，后面超时了
        第二次参考了官方的题解，设置flip记录反转状态，hint记录每次反转的结束位置，不进行真正的反转操作，通过。
        """
        '''
        基本原理是贪心算法，从头开始，每遇到0便进行一次翻转，最终目的是使得不存在无法变为1的0。
        使用filp来记录翻转的状态：初始及反转偶数次为0,反转奇数次为1；使用‘^=1’更改filp的值，进行翻转（1^1=0,0^1=1）。
        filp==0时，遇到0需要修改；filp==1时，遇到1需要修改（翻转后，原来的1以及变为0）；故设置判断条件为x ^ flip == 0（1^1=0;0^0=0）
        '''

        N = len(A)
        hint = [0]*N#构建状态list，记录一次flip时间的结束位置，从而将此次的flip结束
        res = 0#初始化返回结果，即flip次数
        flip = 0#初始化flip状态，即当前是否为已翻转的状态

        for i, x in enumerate(A):#遍历整个array，i，x分别为当前的list坐标与值
            flip ^= hint[i]
            #检查当前位置是否为一次flip的结束位置
            #如果是则hint[i]==1,该操作会将结束的翻转状态对flip的改变去除
            #如果不是则hint[i]==0，不影响flip的状态

            if x ^ flip == 0:#判断是否应在此处启动一次翻转
                #当x与flip一致时，说明此位置之前的反转最终使得该位置为0，从而必需启动一次翻转将其更改为1
                res += 1#通过翻转启动判断，计数一次
                if i+K > N: return -1#判断结果指出此位置必须经过一次翻转才能变为0，但是后续的元素数量不足以翻转，无法完成
                flip ^= 1#由于进行了一次翻转，将翻转状态改变
                if i+K < N: hint[i + K] ^= 1#记录此次此次翻转事件的结束位置。
        return res
